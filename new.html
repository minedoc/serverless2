<!doctype html>
<pre>
minimal sync
  no query
  no realtime query
  no ui toolkit
  no smart arrays
  no schema
  no await
    everything done in-memory
    doesn't matter if indexeddb lags behind - it is used at load time only
    leader election
  manual and code duplication
    local and remote changes are separate
  no dag
    don't need to save un-processable changes
    simple dependency model with no depth
    all needed data is in the change (eg table is duplicate)
    update depends on insert but can be resolved without it

how is old change handled
  merkle tree sounds difficult
  send everything
  names
    set reconciliation
    anti-entropy
  just send all the change id (first 64 bits)
  collision probability ~ keys^2/(2 * keyspace)
    bits = log2(keys^2 / probability)

dag based
  dag is linearized into a consistent timeline
  changes may apply to any point in history
    what about non-commutable changes - O(n) if change is non-commutable

</pre>
<script type="module">

var db;
async function Init() {
  db = await Database({
    name: 'foo',
    tracker: 'wss://tracker.openwebtorrent.com',
    feed: '9aa6481d5855fae13cfe81580b2ebc36becf3d2c',
  });
}
Init();

async function Database(settings) {
  function insert(table, value) {
    const clock = getLatestTime();
    const change = Change.Insert.encode({clock, table, value});
    const rowId = hash(change);
    tables.set(table, rowId, value, clock);
    share.send(change);
    return rowId;
  }
  function update(table, rowId, value) {
    const clock = getLatestTime();
    const change = Change.Update.encode({clock, table, rowId, value});
    tables.set(table, rowId, value, clock);
    share.send(change);
  }
  function remove(table, rowId) {
    const clock = getLatestTime();
    const change = Change.Delete.encode({clock, table, rowId});
    tables.remove(table, rowId, clock);
    share.send(change);
  }

  const idb = await OpenIndexedDb(settings.name);
  const tables = await Tables(idb);
  const share = await Share(idb, Discovery(settings.tracker, settings.feed));
  share.subscribe(change => {
    if (change.type == Change.Insert) {
      tables.set(change.table, hash(change), change.value);
    } else if (change.type == Change.Update) {
      if (change.getClock(change.rowId) < change.clock) {
        tables.set(change.table, change.rowId, change.value, change.clock);
      }
    } else if (change.type == Change.Delete) {
      tables.remove(change.table, change.rowId, change.clock);
    }
  });

  return {get: tables.get, getAll: tables.getAll, insert, update, remove, subscribe: share.subscribe};
}

async function Share(idb, discovery) {
  const peers = new Map();
  const changes = await Changes(idb);
  const handler = {
    getRecentChanges: req => {
      return {changes: changes.after(req.cursor), cursor: changes.cursor()};
    },
    getChangeList: req => {
      const bloomfilter = BloomFilter(req.bloomfilter);
      const missing = [];
      for (const [hash, change] of changes.iterate()) {
        if (!bloomfilter.has(hash)) {
          missing.push(change);
        }
      }
      return {changes: missing, cursor: changes.cursor()};
    },
  };
  function processChanges(c) {
    c.map(change => {
      if (changes.insert(change)) {
        subscribers.send(change);
      }
    });
  }
  discovery.onPeer(async peer => {
    peer.addHandler(handler);
    const resp = await peer.getChangeList(changes.bloomFilterBinary());
    peers.set(peer.id, {peer, cursor: resp.cursor});
    processChanges(resp.changes);
  });
  setInterval(() => {
    peers.forEach(async peer => {
      const resp = await peer.getRecentChanges(peer.cursor);
      peer.cursor = resp.cursor;
      processChanges(resp.changes);
    });
  }, 1000);
  return {send, subscribe}
}

function Changes(idb) {
  const changes = new Map();
  const index = [];
  let bloomFilter;
  const cursor = () => index.length;
  const after = cursor => index.slice(cursor);
  const iterate = () => changes.entries();
  function insert(change) {
    const id = hash(change);
    if (!changes.has(id)) {
      insertHashed(id, change);
      return true;
    } else {
      return false;
    }
  }
  function insertHashed(hash, change) {
    changes.set(hash, change);
    index.push(change);
    bloomFilter.add(hash);
    idb.transaction('changes', 'readwrite').objectStore('changes').put({hash, change});
  }
  return new Promise((resolve, reject) => {
    const req = idb.transaction('changes', 'readonly').objectStore('changes').getAll();
    req.onerror = () => reject(req.error);
    req.onsuccess = () => {
      bloomFilter = new BloomFilter(req.result.length, 0.0000001);
      for(const row of req.result) {
        insertHashed(row.hash, row.change);
      }
      resolve({bloomFilterBinary: bloomFilter.toBinary, insert, cursor, after, iterate});
    }
  });
}

function OpenIndexedDb(name) {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(name, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      switch (event.oldVersion) {
        case 0:
          const tables = db.createObjectStore('tables', {keyPath: 'id', autoIncrement: false});
          const changes = db.createObjectStore('changes', {keypath: 'hash', autoIncrement: false});
      }
    };
    req.onerror = () => reject(req.error);
    req.onsuccess = () => resolve(req.result);
  });
}

// todo: batch writes
function Tables(idb) {
  const tables = new Map();
  const clocks = new Map();

  const get = (table, rowId) => getAll(table).get(rowId);
  const getClock = rowId => clocks.get(rowId);
  function getAll(table) {
    if (!tables.contains(table)) {
      tables.set(table, new Map());
    }
    return tables.get(table);
  }
  function set(table, rowId, clock, value) {
    getAll(row.table).put(rowId, value);
    clocks.put(rowId, clock);
    idb.transaction('tables', 'readwrite').objectStore('tables').put({id: [table, rowId], clock, value});
  }
  function remove(table, rowId, clock) {
    getAll(row.table).remove(rowId, clock);
    clocks.put(rowId, clock);
    idb.transaction('tables', 'readwrite').objectStore('tables').put({id: [table, rowId], clock});
  }
  return new Promise((resolve, reject) => {
    const req = idb.transaction('tables', 'readonly').objectStore('tables').getAll();
    req.onerror = () => reject(req.error);
    req.onsuccess = () => {
      for(const row of req.result) {
        if (row.value) {
          getAll(row.id[0]).put(row.id[1], row.value);
        }
        clocks.put(row.id[1], row.clock);
      }
      resolve({get, getClock, getAll, set, remove});
    }
  });
}

</script>
