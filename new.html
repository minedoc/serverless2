<!doctype html>
<script type="module">
import {init} from './init.js';
init();
</script>

<pre>
todo
  P0 - how to derive random binary
    createDatabase(server, encryption) - connectionObj
    openDatabase(connectionObj)
  P0 - size limit of webrtc, how to deal with huge sync
  P1 - having loading and connectivity state
    empty - new db
    empty - no peers
    empty - fetching (progress)
    offline
    online
  P2 - encryption
    acl writes
      signature: public can verify, private can sign
      verify - 50k message per sec O(1)
    acl reads - encrypt
      transport level encryption
      symmetric: use aes-gcm with 12 byte random value
      decrypt - 50k messages per sec O(length)
      A: randomA then encrypt(data, key, randomA)
  P2 - detect conflicts on startup diff
    you receive newer write and they missing your older write
  P4 - batch changes to do less encryption

minimal sync
  no query
    map and filter the Dict yourself
    no indexes
  no realtime query
    re-query to get new values
  no ui
    this is a db
  no schema
    that's a bad idea
  no await
    data stored in memory, indexed db is persistence only
  no concurrency
    use transactions when modifying idb to ensure correctness
  no dag
    changes are self sufficient
    last writer wins
    cannot statically detect conflicting edits
      normal writes form linked list
      conficting writes form tree
  yes encryption - but later
    authenticity - sign
    privacy - encrypt
  no strings - for now
    future: accumulating set of edits, apply library or replicated growable arrays

correctness
  multiple unsynchronized users of idb
  idb changes are not pushed to other users
  local sync with idb
    changes: writes are key hashed thus idempotent
    tables: use indexeddb transaction compare clock and overwrite

data model
  tables of lww rows
  API
    table(table)
    insert(table, value) returns key
    update(table, key, value)
    remove(table, key)

</pre>

<script>


</script>
