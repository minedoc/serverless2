<!doctype html>
<script type="module">
import {init} from './init.js';
init();
</script>

<pre>
minimal sync
  no query
  no realtime query
  no ui toolkit
  no smart arrays
  no schema
  no await
    everything done in-memory
    doesn't matter if indexeddb lags behind - it is used at load time only
    leader election
  manual and code duplication
    local and remote changes are separate
  no dag
    don't need to save un-processable changes
    simple dependency model with no depth
    all needed data is in the change (eg table is duplicate)
    update depends on insert but can be resolved without it

how is old change handled
  merkle tree sounds difficult
  send everything
  names
    set reconciliation
    anti-entropy
  just send all the change id (first 64 bits)
  collision probability ~ keys^2/(2 * keyspace)
    bits = log2(keys^2 / probability)

dag based
  dag is linearized into a consistent timeline
  changes may apply to any point in history
    what about non-commutable changes - O(n) if change is non-commutable

</pre>

<script>


</script>
